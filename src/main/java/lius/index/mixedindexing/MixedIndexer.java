package lius.index.mixedindexing;/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements.  See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License.  You may obtain a copy of the License at * *      http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */import java.io.File;import java.io.FileInputStream;import java.io.FileNotFoundException;import java.io.IOException;import java.util.Collection;import java.util.Iterator;import java.util.List;import lius.config.LiusConfig;import lius.config.LiusField;import lius.index.BaseIndexer;import lius.index.Indexer;import lius.index.IndexerFactory;import lius.index.MimeTypeUtils;import lius.index.ParsingResult;import lius.index.util.LiusUtils;import org.apache.log4j.Logger;import org.springframework.core.io.FileSystemResource;import org.springframework.core.io.Resource;/** * Classe permettant d'effectuer une indexation mixte. Cette indexation permet * d'integrer dans le même "Lucene Document" des méta-données dans format XML et * le texte integral dans un fichier PDF Word etc. <br/><br/> Class for mixed * indexation. This indexation allows for integrating in the same Lucene * document XML metadata and full text from a PDF file, Word file, etc. *  * @author Rida Benjelloun (ridabenjelloun@gmail.com) */public class MixedIndexer extends BaseIndexer {    static Logger logger = Logger.getLogger(MixedIndexer.class);    @Override    public int getType() {        return 0;    }    @Override    public boolean isConfigured(LiusConfig liusConfig) {        return liusConfig.getMixedFields() != null;    }    @Override    public Collection getConfigurationFields(LiusConfig liusConfig) {        return liusConfig.getMixedFields();    }    private interface IndexVisitor {        public void index(Indexer indexService, Resource resource);    }    /**     * Retourne une collection contenant les champs avec les valeurs à indexer     * comme par exemple: le texte integrale, titre etc. <br/><br/>Returns a     * collection containing the fieds with the values to index, like : full     * text, title, etc.     */    @Override    public ParsingResult parseResource(final LiusConfig liusConfig,            Resource mixedContent) {        try {            final ParsingResult result = new ParsingResult("");            indexAll(mixedContent.getFile(), liusConfig, new IndexVisitor() {                public void index(Indexer indexer, Resource resource) {                    if ((indexer.isConfigured(liusConfig))                            && (indexer.getType() == BaseIndexer.INDEXER_CONFIG_FIELDS_COL)) {                        Iterator cit = getConfigurationFields(liusConfig)                                .iterator();                        while (cit.hasNext()) {                            LiusField mf = (LiusField) cit.next();                            if (indexer.getMimeType(resource).equals(                                    mf.getFileMimeType())) {                                ParsingResult populCollFile = indexer                                        .parseResource(liusConfig, resource);                                LiusField lff = new LiusField();                                lff.setName("path");                                lff.setValue(resource.getDescription());                                lff.setType("Keyword");                                populCollFile.add(lff);                                result.addAll(populCollFile);                            }                        }                    }                }            });            result.reinit();            return result;        } catch (IOException e) {            throw new IllegalArgumentException(e);        }    }    // This methode return a list of Indexer's, from directory or ZIP file    public static void indexAll(File toIndexF, LiusConfig lc,            IndexVisitor indexVisitor) {        File[] lf = null;        if (toIndexF.isDirectory()) {            for (File file : toIndexF.listFiles()) {                indexAll(file, lc, indexVisitor);            }        } else if (MimeTypeUtils.getMimeType(toIndexF)                .equals("application/zip")) {            List files = null;            try {                files = LiusUtils.unzip(new FileInputStream(toIndexF));            } catch (FileNotFoundException e) {                LiusUtils.doOnException(e);            }            for (int i = 0; i < files.size(); i++) {                indexAll((File) files.get(i), lc, indexVisitor);            }        } else {            FileSystemResource fileSystemResource = new FileSystemResource(                    toIndexF);            indexVisitor.index(IndexerFactory                    .getIndexer(fileSystemResource, lc), fileSystemResource);        }    }}